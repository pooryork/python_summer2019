\documentclass[bachelor, och, pract, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    nir      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage{verbatim}
\usepackage[english,russian]{babel}


\usepackage[colorlinks=true]{hyperref}


\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{информатики и программирования}

% Тема работы
\title{Алгоритмы и структуры данных STL}

% Курс
\course{1}

% Группа
\group{142}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета компьютерных наук и информационных технологий}

% Специальность/направление код - наименование

\napravlenie{02.03.03 "--- Математическое обеспечение и администрирование информационных систем}


% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Бурдавицына Артёма Андреевича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н.} % степень, звание
\chname{М.\,В.\,Огнева}

%Научный руководитель 
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{К.\,П.\,Вахлаева}

%Если научный руководитель Грецова А.П., то раскомментируйте это и закомментируйте то(или удалите).
%\satitle{старший преподаватель} %должность, степень, звание
%saname{А.\,П.\,Грецова}

% Семестр 
\term{2(3)}

% Наименование практики 
\practtype{учебная}

% Продолжительность практики (количество недель) 
\duration{2}

% Даты начала и окончания практики 
\practStart{29.06.2018}
\practFinish{12.07.2018}

% Год выполнения отчета
\date{2018}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
\secNumbering


\tableofcontents




% Раздел "Введение"
\intro
Библиотека стандартных шаблонов (STL) (англ. Standard Template Library) — набор согласованных обобщённых алгоритмов, контейнеров, средств доступа к их содержимому и различных вспомогательных функций в C++.

В ходе практики были изучены такие инструменты библиотеки, как:
\begin{itemize}
    \item контейнеры (ассоциативные, последовательные и адаптеры);
    \item алгоритмы;
    \item итераторы;
    \item функторы.
\end{itemize}

Библиотека STL является неотъемлемой частью языка C++, позволяющей сократить количество строк кода и затрат времени благодаря включенным в неё методам и классам. STL широко применяется в программировании, предоставляя программисту большой спектр возможностей, которыми удобно воспользоваться во многих ситуациях. Библиотека проста в применении, удобна и многофункциональна, поэтому разобраться в её работе полезно для программиста любого уровня.



\section{История и общие сведения о библиотеке}

Библиотека стандартных шаблонов до включения в стандарт C++ была сторонней разработкой, вначале — фирмы HP, а затем SGI. Стандарт языка не называет её «STL», так как эта библиотека стала неотъемлемой частью языка, однако многие люди до сих пор используют это название, чтобы отличать её от остальной части стандартной библиотеки.

Архитектура библиотеки была разработана Александром Степановым и Менг Ли.\cite{Ammeral}.

В библиотеке выделяют пять основных компонентов:

\begin{enumerate}
\item Контейнер (англ. container)  ~--- хранение набора объектов в памяти.
\item Итератор (англ. iterator)  ~--- обеспечение средств доступа к содержимому контейнера.
\item Алгоритм (англ. algorithm)  ~--- определение вычислительной процедуры.
\item Адаптер (англ. adaptor)  ~--- адаптация компонентов для обеспечения различного интерфейса.
\item Функциональный объект (англ. functor)  ~--- сокрытие функции в объекте для использования другими компонентами.
\end{enumerate}

Здесь приведем пример, ссылок на литературу.

Первый список \cite{cplusplus}.

Второй\cite{Jo}

Третий\cite{Satter}

Четвертый\cite{SatterD}

Пятый\cite{Meyers}

Шестой\cite{Ogneva}

Седьмой\cite{Kudrina}

Восьмой \cite {Course}

Ничего страшного если вы вновь ссылаетесь на туже литературу. Он вас поймет\cite{Ammeral}



\section{Последовательные контейнеры}

Последовательные контейнеры библиотеки STL помогают осуществлять хранение данных и доступ к ним. Их особенность заключается том, что они поддерживают указанный пользователем порядок вставляемых элементов. Среди последовательных контейнеров различают векторы, списки и деки (двусторонние очереди).

\subsection{Вектор}

Вектор, по сути, является стандартной реализацией двумерного массива, что позволяет хранить неограниченное количество элементов в одном массиве. Принцип работы вектора аналогичен принципу работы динамического массива. В векторе организован произвольный доступ к элементам, т.е к любому элементу можно обратиться по его индексу.

Подробная схема работы вектора представлена на рисунке~\ref{fig:vector-01}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.9]{vector.png}
    \caption{Схема Вектора}\label{fig:vector-01}
\end{figure}

Для работы с векторами существуют стандартные функции.

<<Перечень функций представлены в таблице>>~\ref{tab:vector}.


\begin{table}[!ht]
    \small
    \caption{Функции для работы с контейнером vector }\label{tab:vector}
    \begin{tabular}{|p{10em}|p{27em}|}\hline
    Функция & Описание\cr\hline
   
    \verb".empty()" & \verb"Проверка вектора на пустоту. Возвращает значение true,"\cr
    \verb" " & \verb"если вектор пуст"\cr\hline
    \verb".front()" & \verb"Возвращает значение первого элемента"\cr\hline
    \verb".back()" & \verb"Возвращает значение последнего элемента"\cr\hline
    \verb".push-back()" & \verb"Осуществляет вставку элемента в конец массива"\cr\hline
    \verb".clear()" & \verb"Очистка вектора"\cr\hline
    \verb".pop-back()" & \verb"Удаление последнего элемента"\cr\hline
    \verb".size()" & \verb"Получение количества элементов вектора"\cr\hline
    \verb".begin()" & \verb"Получение индекса начала вектора"\cr\hline
    \end{tabular}
\end{table}


\textsc{Задача 1 (A).} Дана последовательность целых чисел. Продублировать k-ый элемент

Устанавливаем итератор на k-й элемент. С помощью функции insert вставляем на k-ю позицию значение k-го элемента.

\begin{Verbatim}[fontsize=\small]
.....
 it = vector1.begin() + k;
.....
 vector1.insert(it - 1, *(it - 1));
.....
\end{Verbatim}

Полный код программы приведен в приложении~\ref{pril:vector}.\\

\textsc{Задача 9 (Б).} Дана последовательность целых чисел. Вставить после первого и перед последним элементы, получающиеся из исходных перестановкой цифр в обратном порядке.

Создаем вспомогательную функцию, переставляющую цифры числа в обратной порядке. Устанавливаем итератор на элемент, следующий после первого. Вставляем туда число полученное перестановкой цифр для первого числа.

\begin{Verbatim}[fontsize=\small]
.....
 it = vector1.begin() + 1;
 		int a = vector1[0];
 		a = invert(a);
 		vector1.insert(it, a);
 		++n;
.....
\end{Verbatim}

Аналогично для вставки числа перед последним элементом.\\

Полный код программы приведен в приложении~\ref{pril:vector}.

\subsection{Список}

Список (list) представляет собой последовательный контейнер, который поддерживает быструю вставку и удаление элементов из любой позиции в контейнере. Список отличается от вектора тем, что доступ к элементам осуществляется последовательно, т.е чтобы добраться к нужному элементу, необходимо перебрать все элементы до него.

Подробная схема работы списка представлена на рисунке~\ref{fig:list-01}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.9]{list.png}
    \caption{Схема Списка}\label{fig:list-01}
\end{figure}

Для работы с списками существуют стандартные функции.

<<Перечень функций представлены в таблице>>~\ref{tab:list}.


\begin{table}[!ht]
    \small
    \caption{Функции для работы с контейнером list }\label{tab:list}
    \begin{tabular}{|p{10em}|p{27em}|}\hline
    Функция & Описание\cr\hline
   
    \verb".empty()" & \verb"Проверка на пустоту. Возвращает значение true,"\cr
    \verb" " & \verb"если список пуст"\cr\hline
    \verb".front()" & \verb"Возвращает значение первого элемента"\cr\hline
    \verb".back()" & \verb"Возвращает значение последнего элемента"\cr\hline
    \verb".push-back()" & \verb"Осуществляет вставку элемента в конец"\cr\hline
    \verb".push-front()" & \verb"Осуществляет вставку элемента в начало"\cr\hline
    \verb".pop-front()" & \verb"Удаление первого элемента"\cr\hline
    \verb".clear()" & \verb"Очистка списка"\cr\hline
    \verb".pop-back()" & \verb"Удаление последнего элемента"\cr\hline
    \verb".size()" & \verb"Получение количества элементов списка"\cr\hline
    \verb".erase()" & \verb"Удаление выбранного элемента"\cr\hline
    \end{tabular}
\end{table}

\textsc{Задача 8 (A).} Заменить средний элемент на сумму первого и последнего, если количество элементов нечетное.\\

Находим сумму первого и последнего элементов как сумму указателей на соответствующие итераторы. 

\begin{Verbatim}[fontsize=\small]
.....
 it1 = --list1.end();
 it2 = list1.begin();
 int a = *it1 + *it2;
.....
\end{Verbatim}

С помощью функции erase удаляем средний элемент, на его места вставляем ранее найденную сумму. 

\begin{Verbatim}[fontsize=\small]
.....
 it = list1.begin();
 advance(it, n / 2);
 list1.erase(it);
 it = list1.begin();
 advance(it, n / 2);
 list1.insert(it, a);
.....
\end{Verbatim}

Полный код программы приведен в приложении~\ref{pril:list}.\\

\textsc{Задача 4 (Б).} Заменить последний и первый элементы на средний \\

Устанавливаем итератор на средний элемент. Находим значение среднего элемента как указатель на данный итератор.

\begin{Verbatim}[fontsize=\small]
.....
 it = list1.begin();
 advance(it, n / 2);
 int a = *it;
.....
\end{Verbatim}

Устанавливаем итератор на первый элемент. С помощью erase удаляем его. На его места вставляем нужное значение.

\begin{Verbatim}[fontsize=\small]
.....
 it = list1.begin();
 		list1.erase(it);
 		it = list1.begin();
 		list1.insert(it, a);
.....
\end{Verbatim}

Аналогично для замены последнего элемента.

Полный код программы приведен в приложении~\ref{pril:list}.\\

\subsection{Дек}
Дек (deque - Double-Ended-Queue) — двусторонняя очередь, т.е очередь, каждая ячейка которой содержит в себе указатель как на предыдущий, так и на следующий элемент. Это позволяет очень быстро добавлять новые элементы как в конец так и в начало контейнера.

Принцип работы дека аналогичен принципу работы списка.

Для работы с деками существуют стандартные функции.

Перечень функций представлены в таблице~\ref{tab:deque}.


\begin{table}[!ht]
    \small
    \caption{Функции для работы с контейнером deque }\label{tab:deque}
    \begin{tabular}{|p{10em}|p{27em}|}\hline
    Функция & Описание\cr\hline
   
    \verb".empty()" & \verb"Проверка на пустоту. Возвращает значение true,"\cr
    \verb" " & \verb"если дек пуст"\cr\hline
    \verb".front()" & \verb"Возвращает значение первого элемента"\cr\hline
    \verb".back()" & \verb"Возвращает значение последнего элемента"\cr\hline
    \verb".push-back()" & \verb"Осуществляет вставку элемента в конец"\cr\hline
    \verb".push-front()" & \verb"Осуществляет вставку элемента в начало"\cr\hline
    \verb".pop-front()" & \verb"Удаление первого элемента"\cr\hline
    \verb".clear()" & \verb"Очистка списка"\cr\hline
    \verb".pop-back()" & \verb"Удаление последнего элемента"\cr\hline
    \verb".size()" & \verb"Получение количества элементов списка"\cr\hline
    \verb".erase()" & \verb"Удаление выбранного элемента"\cr\hline
    \end{tabular}
\end{table}
 
 \textsc{Задача 17.}  Создать список из слов. Исключить из списка повторяющиеся слова.\\
 
 С помощью двух вложенных циклов проходим по списку и ищем повторяющиеся слова. При нахождении каждого из них с помощью erase удаляем второе повторяющееся слово, уменьшаем общее количество элементов и счетчик второго цикла на 1, с помощию переменной flag типа bool обозначаем, что необходимо удалить первый из повторяющихся элементов. Аналогично удаляем его.
 
 \begin{Verbatim}[fontsize=\small]
 .....
  for (int i = 0; i < n; ++i) {
  
  	deque <string>::iterator it;
  	bool flag = false;
  
  	for (int j = i+1; j < n; ++j) {
  		if (deque1[i] == deque1[j]) {
  			it = deque1.begin();
  			advance(it, j);
  			deque1.erase(it);
  			--n;
  			--j;
  			flag = true;
  		}
  	}
 .....
 \end{Verbatim}
 
 
 Полный код программы приведен в приложении~\ref{pril:deque}.\\
 
 \textsc{Задача 18.}  Создать список из целых чисел. Создать новый список, записав в него вначале все положительные числа, а затем все отрицательные числа из исходного списка.\\
 
 Создаем второй список. С помощью функций pushback и pushfront записываем во второй список отрицательные и положительные числа соответственно.
 
 \begin{Verbatim}[fontsize=\small]
  .....
   it = deque1.begin();
   
   	for (int i = 0; i < n; ++i) {
   
   		int a = *it;
   		if (a > 0) deque2.push_front(a);
   		else if (a < 0) deque2.push_back(a);
   
   		advance(it, 1);
   
   	}
  .....
  \end{Verbatim}
  
  Полный код программы приведен в приложении~\ref{pril:deque}.\\
 
\section{Итераторы, алгоритмы, функторы}

Итератор — это объект, который может выполнять итерацию элементов в контейнере STL и предоставлять доступ к отдельным элементам. Все контейнеры STL предоставляют итераторы, чтобы алгоритмы могли получить доступ к своим элементам стандартным способом, независимо от типа контейнера, в котором сохранены элементы.

Вы можете использовать итераторы явно, с помощью члена и глобальных функций, таких как begin() и end(), а также операторов ++ и -- для перемещения вперед или назад. Вы можете также использовать итераторы неявно, с циклом range-for или (для некоторых типов итераторов) подстрочным оператором [].

В STL началом последовательности или диапазона является первый элемент. Конец последовательности или диапазона всегда определяется как элемент, следующий за последним элементом.\\

Подробная схема работы списка представлена на рисунках~\ref{fig:iterator1-01}, ~\ref{fig:iterator2-01}, ~\ref{fig:iterator3-01}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.9]{iterator1.png}
    \caption{Схема Итератора 1}\label{fig:iterator1-01}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.9]{iterator2.png}
    \caption{Схема Итератора 2}\label{fig:iterator2-01}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.9]{iterator3.png}
    \caption{Схема Итератора 3}\label{fig:iterator3-01}
\end{figure}

Алгоритмы STL универсальны, поскольку они могут работать с различными структурами данных. Структуры данных, с которыми они могут работать, включают в себя не только классы контейнеров STL, но также определенные программой структуры данных и массивы элементов, удовлетворяющие требованиям определенного алгоритма. Алгоритмы STL достигают такого уровня универсальности путем получения доступа к элементам контейнера и их просмотра опосредованным образом через итераторы.

Алгоритмы STL обрабатывают диапазоны итератора, которые обычно определяются их начальными или конечными позициями. Указанные диапазоны должны быть допустимы в том смысле, что все указатели в диапазонах должны поддерживать удаление ссылок и в рамках последовательностей каждого диапазона последняя позиция должна быть доступна из первой путем приращения.

Алгоритмы STL расширяют действия, поддерживаемые операциями и функциями-членами каждого контейнера STL, и позволяют работать, например, с различными типами объектов контейнера одновременно.

Перечень наиболее часто использующихся алгоритмов представлен в таблице~\ref{tab:algorithm}.


\begin{table}[!ht]
    \small
    \caption{Некоторые функции для работы с algorithm }\label{tab:algorithm}
    \begin{tabular}{|p{10em}|p{27em}|}\hline
    Функция & Описание\cr\hline
   
    \verb".sort()" & \verb"Сортировка контейнера по возрастанию некоторого поля"\cr\hline
    \verb".erase()" & \verb"Очищает элементы из заданного диапазона"\cr\hline
    \verb".count()" & \verb"Считает количество элементов данного диапазона"\cr\hline
    \verb".remove()" & \verb"Удаляет из диапазона все значения, равные заданному"\cr\hline
    \verb".binary-search()" & \verb"Возвращает true, если заданное значение "\cr
    \verb"" & \verb" входит в интервал"\cr\hline
    \verb".lower_bound()" & \verb"Возвращает итератор, указывающий на первую позицию,"\cr
    \verb"" & \verb" в которую можно вставить заданное значение"\cr
    \verb"" & \verb"без изменения порядка следования объектов"\cr\hline
    \verb".upper_bound()" & \verb"Возвращает итератор, указывающий на последнюю позицию,"\cr
    \verb"" & \verb"в которую можно вставить  заданное значение"\cr
    \verb"" & \verb" без изменения порядка следования объектов"\cr\hline
    \verb"set_difference()" & \verb"Создает упорядоченную разность множеств,"\cr
    \verb"" & \verb" заданных диапазонами 1 и 2"\cr\hline
    \verb"set_intersection()" & \verb"Создает упорядоченное пересечение множеств,"\cr
    \verb"" & \verb" заданных диапазонами 1 и 2"\cr\hline
    \end{tabular}
\end{table}

Для большинства алгоритмов существуют их аналоги с суффиксами if и copy.

Суффикс if указывает, что алгоритм работает с объектами функций, действующих для значений элементов, а не с самими значениями элементов. Например, алгоритм find-if выполняет поиск элементов, значения которых удовлетворяют критерию, заданному объектом функции, а алгоритм find ищет определенное значение.

Суффикс copy означает, что этот алгоритм не только манипулирует значениями элементов, но также копирует измененные значения в диапазон назначения. Например, алгоритм reverse изменяет порядок элементов в диапазоне на обратный, а алгоритм reverse-copy также копирует результат в диапазон назначения.

Для их использования необходимо добавить предикат, принимающий булевые значения, как дополнительный параметр.\\

 Функтор — это сокращение от функциональный объект, представляющий собой конструкцию, позволяющую использовать объект класса как функцию. В C++ для определения функтора достаточно описать класс, в котором переопределена операция ().\\

\textsc{Задача 1.}  Точки на плоскости заданы парами целочисленных координат.

а) удалить все точки из I четверти

б) подсчитать количество точек, у которых x и y совпадают

в) найти наиболее удалённую от начала координат точку

г) расположить в порядке возрастания координаты x\\


Создадим структуру Point для хранения координат введенных точек.

\begin{Verbatim}[fontsize=\small]
.....
 struct Point {
 public:
 	int x;
 	int y;
 
 	Point(int x, int y) {
 
 		this->x = x;
 		this->y = y;
 
 	}
 
 };
 .....
\end{Verbatim}

Для пункта а) необходимо использовать функции removeif и erase. Removeif удаляет из заданного диапазона элементы, соответствующие некоторому условию, и возвращает итератор, указывающий на начало. Erase удаляет элементы из заданного диапазона.

\begin{Verbatim}[fontsize=\small]
.....
 point.erase(remove_if(point.begin(), point.end(), f), point.end());
 .....
\end{Verbatim}

Для пункта б) необходимо использовать функцию countif, возвращающую количество элементов из заданного диапазона, удовлетворяющие некоторому условию.

\begin{Verbatim}[fontsize=\small]
.....
 s = count_if(point.begin(), point.end(), f1);
 .....
\end{Verbatim}

Для пункта в) необходимо использовать функцию maxelement, устанавливающую итератор на элемент из заданного диапазона, удовлетворяющие некоторому условию.

\begin{Verbatim}[fontsize=\small]
.....
 i = max_element(point.begin(), point.end(), compare);
 .....
\end{Verbatim} 

Для пункта г) необходимо использовать функцию sort, сортирующую элементы из заданного диапазона по возрастанию первой координаты.

\begin{Verbatim}[fontsize=\small]
.....
 i = max_element(point.begin(), point.end(), compare);
 .....
\end{Verbatim}

Полный код программы приведен в приложении~\ref{pril:algorithm}.



\section{Контейнеры-адаптеры}

Контейнер-адаптер — это разновидность последовательного или ассоциативного контейнера, который ограничивает интерфейс для простоты и ясности. Контейнеры-адаптеры не поддерживают итераторы, поэтому их нельзя использовать для работы с алгоритмами STL.
Среди контейнеров-адапткров различают стек и очередь.

\subsection{Стек}

Стек (stack — стопка) — абстрактный тип данных, имеющих одну точку доступа (голову), т.е представляющий собой список элементов, организованных по принципу LIFO (last in — first out, «последним пришёл — первым вышел»).

Подробная схема работы стека представлена на рисунке~\ref{fig:stack1-01}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.9]{stack1.jpg}
    \caption{Схема Стека}\label{fig:stack1-01}
\end{figure}
 
Для работы со стеками существуют стандартные функции.

Перечень функций представлен в таблице~\ref{tab:stack}.\\


\begin{table}[!ht]
    \small
    \caption{Функции для работы с контейнером stack }\label{tab:stack}
    \begin{tabular}{|p{10em}|p{27em}|}\hline
    Функция & Описание\cr\hline
   
    \verb".empty()" & \verb"Проверка на пустоту. Возвращает значение true,"\cr
    \verb" " & \verb"если стек пуст"\cr\hline
    \verb".top()" & \verb"Возвращает значение первого элемента"\cr\hline
    \verb".pop()" & \verb"Удаляет первый элемент"\cr\hline
    \verb".push()" & \verb"Осуществляет вставку элемента в начало"\cr\hline
    \verb".size()" & \verb"Получение количества элементов стека"\cr\hline
    \end{tabular}
\end{table}
 
 \textsc{Задача 1 (А).}  Удалить первый кратный трём элемент.\\
 
 Создаем 2 стека. В первый стек записываем все числа. Для того, чтобы удалить нужный элемент, с помощью переменной типа bool отмечаем первый кратный трем элемент, чтобы удалить только его. 
 
 \begin{Verbatim}[fontsize=\small]
 .....
  if (a % 3 == 0 && f == false) {
  
  			num = i;
  			f = true;
  
  		}
 .....
 \end{Verbatim}
 
 Переписываем второй стек только нужные элементы из первого стека.
 
 Полный код программы приведен в приложении~\ref{pril:stack-queue}.\\
 
 \textsc{Задача 17 (Б).}  Заменить первый, средний и последний элемент на единицы, если они простые.\\
 
 Создаем вспомогательную функцию для проверки числа на простоту. В первый стек записываем все числа. В цикле переписываем элементы из первого стека во второй и если номер элемента соответствует условию, то меняем его на единицу.
 
  \begin{Verbatim}[fontsize=\small]
 .....
    while (!stack1.empty()) {
    
    		a = stack1.top();
    		stack1.pop();
    
    		if ((i == 1 || i == n || i == mid_num) && ifNotPrime(a) == false)
    			a = 1;
    
    			stack2.push(a);
    
    		++i;
    
    	}
 .....
   \end{Verbatim}
   
   Полный код программы приведен в приложении~\ref{pril:stack-queue}.\\
   
   
 
\subsection{Очередь}
Очередь (queue) — абстрактный тип данных, имеющих 2 точки доступа (голову и хвост), т.е представляющий собой список элементов, организованных по принципу FIFO (first in — first out, «первым пришёл — первым вышел»).

Подробная схема работы стека представлена на рисунках~\ref{fig:queue-01}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.9]{queue.png}
    \caption{Схема Очереди}\label{fig:queue-01}
\end{figure}

Для работы с очередью существуют стандартные функции.

Перечень функций представлен в таблице~\ref{tab:queue}.\\


\begin{table}[!ht]
    \small
    \caption{Функции для работы с контейнером queue }\label{tab:queue}
    \begin{tabular}{|p{10em}|p{27em}|}\hline
    Функция & Описание\cr\hline
   
    \verb".empty()" & \verb"Проверка на пустоту. Возвращает значение true,"\cr
    \verb" " & \verb"если очередь пуста"\cr\hline
    \verb".pop()" & \verb"Удаляет последний элемент"\cr\hline
    \verb".push()" & \verb"Осуществляет вставку элемента в начало"\cr\hline
    \verb".size()" & \verb"Получение количества элементов очереди"\cr\hline
    \verb".front()" & \verb"Возвращает первый элемент"\cr\hline
    \verb".back()" & \verb"Возвращает последний элемент"\cr\hline
    \end{tabular}
\end{table}

\textsc{Задача 10.}  Дано N очередей. С ними выполняют K операций PUSH(I, V), TOP(I), POP(I) -- добавить в хвост очереди I число V, показать число в голове очереди I и удалить число из головы очереди I (при этом результат показывается). Результат должен содержать столько чисел, сколько операций TOP и POP было сделано.\\

Создаем динамический массив очередей.

\begin{Verbatim}[fontsize=\small]
 .....
     queue<int> **QArray = new queue<int> *[a]; // массив указателей на очереди
     	for (int i = 0; i < a; i++)
     	{
     		QArray[i] = new queue<int>; // создание объекта очередь
     	}
 .....
    \end{Verbatim}

Из входного файла считываем команды. По нескольким первым буквам распознаем тип команды (PUSH, POP или TOP). В зависимости от типа команды посимвольно считываем одно или два числа. С помощью функции atoi преобразуем переменные с числами типа  string к int. Делаем с соответствующей очередью соответствующие действия.

Например, для функции POP:
 
 \begin{Verbatim}[fontsize=\small]
 .....
     if (str1 == "POP") {
     
     			string str2;
     			int i = 4;
     
     			while (i < str.length() && str[i] != ')') {
     
     				str2 += str[i];
     				++i;
     
     			}
     
     			int num = 0;
     			num = atoi(str2.c_str());
     
     			out << QArray[num-1]->front() << " ";
     			QArray[num-1]->pop();
     
     		}
     
 .....
    \end{Verbatim}
    
    Аналогично для других функций.
    
    Полный код программы приведен в приложении~\ref{pril:stack-queue}.\\

\section{Ассоциативные контейнеры}

В ассоциативных контейнерах элементы вставляются в предварительно определенном порядке — например, с сортировкой по возрастанию. Также доступны неупорядоченные ассоциативные контейнеры. Ассоциативные контейнеры можно объединить в два подмножества: сопоставления (set) и наборы (map).

\subsection{Множество}

Set и multiset реализуют такие сущности как множество и мультимножество. Они содержат некоторое количество отсортированных элементов. При добавлении нового элемента в множество он сразу становится на свое место так, чтобы не нарушать порядка сортировки. Потому как в множестве и мультимножестве все элементы сортируются автоматически. Множества содержат только уникальные элементы, а мультимножества могут содержать дубликаты.

Подробная схема работы сета представлена на рисунке~\ref{fig:set-01}.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.9]{set.jpg}
    \caption{Схема Сета}\label{fig:set-01}
\end{figure}

Для работы с сетами существуют стандартные функции.

Перечень функций представлен в таблице~\ref{tab:set}.\\


\begin{table}[!ht]
    \small
    \caption{Функции для работы с контейнером set }\label{tab:set}
    \begin{tabular}{|p{10em}|p{27em}|}\hline
    Функция & Описание\cr\hline
   
    \verb".empty()" & \verb"Проверка на пустоту. Возвращает значение true,"\cr
    \verb" " & \verb"если сет пуст"\cr\hline
    \verb".size()" & \verb"Получение количества элементов сета"\cr\hline
    \verb".erase()" & \verb"Удаление элемента из сета"\cr\hline
    \verb".insert()" & \verb"Вставляет элемент в сет"\cr\hline
    \verb".clear()" & \verb"Очищает сет"\cr\hline
    \verb".count()" & \verb"Возвращает количество элементов с заданным ключем"\cr\hline
    \verb".find()" & \verb"Возвращает элемент с заданным ключем"\cr\hline
    \end{tabular}
\end{table}

\textsc{Задача 3.}  Найти все такие цифры, которые встречаются только в кратных 10 числах.\\

Создаем вектор, в котором будут храниться исходные числа. Создаем 2 сета. В первый будем записывать цифры всех чисел, не кратных 10. 

\begin{Verbatim}[fontsize=\small]
.....
 for (int i = 0; i < v.size(); i++)
 	{
 
 		if (v[i] % 10 != 0) {
 
 			int k = abs(v[i]);
 			while (k > 0)
 			{
 				int a = k % 10;
 				k = k / 10;
 				set1.insert(a);
 
 			}
 		}
 	}
 .....
\end{Verbatim}

Во второй сет будем записывать все цифры из чисел не кратных 10, не встречающиеся в первом сете.

\begin{Verbatim}[fontsize=\small]
.....
for (int i = 0; i < v.size(); ++i) {

		if (v[i] % 10 == 0) {

			int k = abs(v[i]);

			while (k != 0) {

				int a = k % 10;
				bool f = false;

				for (auto it = set1.begin(); it != set1.end(); ++it) {

					if (*it == a) {

						f = true;
						break;

					}

				}

				if (f == false) set2.insert(a);

				k /= 10;

			}

		}

	}
.....
\end{Verbatim}

Полный код программы приведен в приложении~\ref{pril:set}.

\textsc{Задача 7.}  Дан текст, состоящий из предложений, разделённых знаками препинания из набора «.?!». Предложения в свою очередь состоят из слов, отделённых друг от друга пробелами. Найти слова (без учёта регистра) и их количество, которые встречаются только в повествовательных и вопросительных предложениях.\\

Создаем 3 сета. В первый сет будем складывать слова из восклицательных предложений без учёта регистра.

\begin{Verbatim}[fontsize=\small]
.....
if (str[str.length() - 1] == '!') {

			string str_buf;
			int j = 0;
			while (j < str.length()) {

				if (isalpha(str[j])) {
					str[j] = tolower(str[j]);
					str_buf += str[j];
				}
				else {
					set1.insert(str_buf);
					str_buf.clear();
				}
				++j;
			}
		}
.....
\end{Verbatim}

Во второй сет будем складывать слова из повествовательных и вопросительных предложений.

\begin{Verbatim}[fontsize=\small]
.....
else {

			string str_buf;
			int j = 0;
			while (j < str.length())  {

				if (isalpha(str[j])) {
					str[j] = tolower(str[j]);
					str_buf += str[j];
				}
				else {
					set2.insert(str_buf);
					str_buf.clear();
				}
				++j;
			}
		}
.....
\end{Verbatim}

С помощью функции set-difference помещаем в третий сет уникальные слова из втрого сета (слова из второго сета, не встречающиеся в первом).

\begin{Verbatim}[fontsize=\small]
.....
set_difference(set2.begin(), set2.end(), set1.begin(), set1.end(), 
inserter(set3, set3.begin()));
.....
\end{Verbatim}

Полный код программы приведен в приложении~\ref{pril:set}.

\subsection{Отображение}

Отображение (map) — отсортированный ассоциативный контейнер, который содержит пары ключ-значение с неповторяющимися ключами.
Это отличие от остальных контейнеров делает его пригодным для создания хеш-таблиц.

Подробная схема работы map представлена на рисунке~\ref{fig:map-01}.
 
 \begin{figure}[!ht]
     \centering
     \includegraphics[scale=0.9]{map.png}
     \caption{Схема Map}\label{fig:map-01}
 \end{figure}
 
 Для работы с map существуют стандартные функции, аналогичные функциям работы с сетами.
 
\textsc{Задача 10.}  Во входном файле задан набор слов и целых чисел, разделённых пробелами. Найти все слова, встречающиеся столько же раз, сколько последнее число.\\
 
 Создаем 1 map. Увеличиваем на 1 значение ячейки с номером, соответствующим очередному входному элементу, и запоминаем последнее число.
 
 \begin{Verbatim}[fontsize=\small]
 .....
while (in >> tmp)
	{
		words[tmp]++;
		if (isdigit(tmp[0]))
			str_num = tmp;
	}

	int num = atoi(str_num.c_str());
 .....
 \end{Verbatim}
 
 С помощью итераторов в цикле проходим по map и ищем очередное слово, встречающееся необходимое количество раз. Кладем его в вектор.
 
 \begin{Verbatim}[fontsize=\small]
  .....
 for (auto i = words.begin(); i != words.end(); ++i) {
 
 		string st = i->first;
 		int st2 = i->second;
 		cout << st << " " << st2 << endl;
 
 		if (isalpha(st[0]) && st2==num) {
 
 			vec_ans.push_back(st);
 
 		}
 
 	}
  .....
  \end{Verbatim}
  
  Если вектор не пуст, то выводим его.
 
 Полный код программы приведен в приложении~\ref{pril:map}.

\section{Использование контейнеров и алгоритмов STL}

Здесь важно написать условие задачи. Как планируете реализовать, ну и соответственно фрагменты кода. 

% Раздел "Заключение"
\conclusion


В ходе практики были изучены элементы стандартной библиотеки шаблонов. Были использованы такие контейнеры как \verb"vector", \verb"list", \verb"deque", \verb"stack", \verb"queue", \verb"set", \verb"map", \verb"multiset", \verb"multimap". Использование данных контейнеров существенно упростило и ускорило процесс решения задач, что делает библиотеку STL необходимой для изучения.

Таким образом, библиотека STL --- это применяемые на практике знания, которые помогают значительно уменьшить размер кода программы и быстро оптимизировать его. Универсальность STL является одновременно преимуществом и слабой стороной, т.к.......

% Список литературы
\bibliographystyle{gost780uv}
\bibliography{thesis}

% Окончание основного документа и начало приложений
% Каждая последующая секция документа будет являться приложением
\appendix




\section{Вектор}\label{pril:vector}

\textsc{Задача 1 (A).} Дана последовательность целых чисел. Продублировать k-ый элемент\\

Листинг \verb"vector1A.cpp"
\VerbatimInput[fontsize=\footnotesize, numbers=left, numbersep=2pt]{vector1A.txt}

Пример:

\begin{table}[ht]
    \small
    \begin{tabular}{|p{15em}|p{15em}|}\hline
    Вход & Выход\cr\hline
   
    \verb"9" & \verb""\cr
    \verb"1 2 3 4 5 6 7 8 9" & \verb"1 2 3 3 4 5 6 6 7 8 9 9"\cr
    \verb"K = 3" & \verb""\cr\hline
    \verb"9" & \verb""\cr
    \verb"1 2 3 4 5 6 7 8 9" & \verb"1 1 2 3 4 5 6 6 7 8 9 9"\cr
     \verb"K = 1" & \verb""\cr\hline
    
    \end{tabular}
\end{table}

\textsc{Задача 9 (Б).} Дана последовательность целых чисел. Вставить после первого и перед последним элементы, получающиеся из исходных перестановкой цифр в обратном порядке.\\

Листинг \verb"vector9B.cpp"
\VerbatimInput[fontsize=\footnotesize, numbers=left, numbersep=2pt]{vector9B.txt}

Пример:

\begin{table}[ht]
    \small
    \begin{tabular}{|p{15em}|p{15em}|}\hline
    Вход & Выход\cr\hline
   
    \verb"9" & \verb""\cr
    \verb"12 2 3 4 5 6 7 8 93" & \verb"12 21 3 4 5 6 7 8 39 93"\cr\hline
    \verb"9" & \verb""\cr
    \verb"98 8 7 6 5 4 3 2 12" & \verb"98 89 8 7 6 5 4 3 21 12"\cr
    \hline
    
    \end{tabular}
\end{table}


\section{Список}\label{pril:list}

\textsc{Задача 8 (A).} Заменить средний элемент на сумму первого и последнего, если количество элементов нечетное.\\

Листинг \verb"list8A.cpp"
\VerbatimInput[fontsize=\footnotesize, numbers=left, numbersep=2pt]{list8A.txt}

Пример:

\begin{table}[ht]
    \small
    \begin{tabular}{|p{15em}|p{15em}|}\hline
    Вход & Выход\cr\hline
   
    \verb"5" & \verb""\cr
    \verb"5 4 7 0 1" & \verb"5 4 6 0 1"\cr\hline
    \verb"6" & \verb""\cr
    \verb"6 8 0 6 3 1" & \verb"6 8 0 6 3 1"\cr\hline
    \verb"1" & \verb""\cr
    \verb"1" & \verb"2"\cr
    \hline
    
    \end{tabular}
\end{table}

\textsc{Задача 4 (Б).} Заменить последний и первый элементы на средний \\

Листинг \verb"list4B.cpp"
\VerbatimInput[fontsize=\footnotesize, numbers=left, numbersep=2pt]{list4B.txt}

Пример:

\begin{table}[ht]
    \small
    \begin{tabular}{|p{15em}|p{15em}|}\hline
    Вход & Выход\cr\hline
   
    \verb"5" & \verb""\cr
    \verb"9 6 89 5 1" & \verb"89 6 89 5 89"\cr\hline
    \verb"6" & \verb""\cr
    \verb"42 3 5 2 1 4" & \verb"2 3 5 2 1 2"\cr\hline
    
    \end{tabular}
\end{table}

\section{Дек}\label{pril:deque}

\textsc{Задача 17.}  Создать список из слов. Исключить из списка повторяющиеся слова.\\

Листинг \verb"deque17.cpp"
\VerbatimInput[fontsize=\footnotesize, numbers=left, numbersep=2pt]{deque17.txt}

Пример:

\begin{table}[ht]
    \small
    \begin{tabular}{|p{15em}|p{15em}|}\hline
    Вход & Выход\cr\hline
   
    \verb"cat dog pie cat cat" & \verb"dog pie"\cr\hline
   
    \verb"cat dog pie" & \verb"cat dog pie"\cr\hline

    \verb"cat cat" & \verb" "\cr\hline
    
    \end{tabular}
\end{table}


\textsc{Задача 18.}  Создать список из целых чисел. Создать новый список, записав в него вначале все положительные числа, а затем все отрицательные числа из исходного списка.\\

Листинг \verb"deque18.cpp"
\VerbatimInput[fontsize=\footnotesize, numbers=left, numbersep=2pt]{deque18.txt}

Пример:

\begin{table}[ht]
    \small
    \begin{tabular}{|p{15em}|p{15em}|}\hline
    Вход & Выход\cr\hline
   
    \verb"1 -1 2 -2 3 -3 4 -4 5 -5 6 -6" & \verb"6 5 4 3 2 1 -1 -2 -3 4- 5 -6"\cr\hline
   
    \verb"-1 0 1" & \verb"1 -1"\cr\hline
    
    \end{tabular}
\end{table}

\section{Алгоритмы}\label{pril:algorithm}

\textsc{Задача 1.}  Точки на плоскости заданы парами целочисленных координат.

а) удалить все точки из I четверти

б) подсчитать количество точек, у которых x и y совпадают

в) найти наиболее удалённую от начала координат точку

г) расположить в порядке возрастания координаты x\\


Листинг \verb"algoritm1.cpp"
\VerbatimInput[fontsize=\footnotesize, numbers=left, numbersep=2pt]{algorithm1.txt}

Пример:

\begin{table}[ht]
    \small
    \begin{tabular}{|p{15em}|p{15em}|}\hline
    Вход & Выход\cr\hline
   
    \verb"1 1" & \verb"а) удалить все точки из I четверти"\cr
    \verb"-1 -1" & \verb"(-1,-1), (-10,10), (47,-89), (-47,89)"\cr
    \verb"-10 10" & \verb"б) подсчитать количество точек, у которых x и y совпадают"\cr
    \verb"47 -89" & \verb"1"\cr
    \verb"-47 89" & \verb"в) найти наиболее удалённую от начала координат точку"\cr
    \verb"" & \verb"(47,-89)"\cr
    \verb"" & \verb"г) расположить в порядке возрастания координаты x"\cr
    \verb"" & \verb"(-47,89), (-10,10), (-1,-1), (47,89)"\cr\hline
        
    \end{tabular}
\end{table}

\section{Стек и очередь}\label{pril:stack-queue}

\textsc{Задача 1 (А).}  Удалить первый кратный трём элемент.\\

Листинг \verb"stack1A.cpp"
\VerbatimInput[fontsize=\footnotesize, numbers=left, numbersep=2pt]{stack1A.txt}

Пример:

\begin{table}[ht]
    \small
    \begin{tabular}{|p{15em}|p{15em}|}\hline
    Вход & Выход\cr\hline
   
    \verb"6" & \verb""\cr
   
    \verb"-1 15 8 4 9 1" & \verb"-1 8 4 9 1"\cr\hline
    
    \end{tabular}
\end{table}


\textsc{Задача 17 (Б).}  Заменить первый, средний и последний элемент на единицы, если они простые.\\

Листинг \verb"stack17B.cpp"
\VerbatimInput[fontsize=\footnotesize, numbers=left, numbersep=2pt]{stack17B.txt}

Пример:

\begin{table}[ht]
    \small
    \begin{tabular}{|p{15em}|p{15em}|}\hline
    Вход & Выход\cr\hline
   
    \verb"6" & \verb""\cr
   
    \verb"11 2 3 4 5 6" & \verb"1 2 3 4 5 6"\cr\hline
    
    \verb"5" & \verb""\cr
       
    \verb"5 4 3 2 7" & \verb"1 4 1 2 1"\cr\hline
    
    \end{tabular}
\end{table}


\textsc{Задача 10.}  Дано N очередей. С ними выполняют K операций PUSH(I, V), TOP(I), POP(I) -- добавить в хвост очереди I число V, показать число в голове очереди I и удалить число из головы очереди I (при этом результат показывается). Результат должен содержать столько чисел, сколько операций TOP и POP было сделано.\\

Листинг \verb"queue10.cpp"
\VerbatimInput[fontsize=\footnotesize, numbers=left, numbersep=2pt]{queue10.txt}

Пример:

\begin{table}[ht]
    \small
    \begin{tabular}{|p{15em}|p{15em}|}\hline
    Вход & Выход\cr\hline
   
    \verb"100 6" & \verb""\cr
    \verb"PUSH(100,1)" & \verb""\cr
    \verb"PUSH(100,3)" & \verb""\cr
    \verb"POP(100)" & \verb"1 3 3"\cr
    \verb"PUSH(50,3)" & \verb""\cr
    \verb"TOP(50)" & \verb""\cr
    \verb"TOP(100)" & \verb""\cr\hline
    
    
    \end{tabular}
\end{table}

\section{Множество}\label{pril:set}

\textsc{Задача 3.}  Найти все такие цифры, которые встречаются только в кратных 10 числах.\\

Листинг \verb"set3.cpp"
\VerbatimInput[fontsize=\footnotesize, numbers=left, numbersep=2pt]{set3.txt}

Пример:

\begin{table}[ht]
    \small
    \begin{tabular}{|p{15em}|p{15em}|}\hline
    Вход & Выход\cr\hline
   
    \verb"100 6 130 40 50 60 13 " & \verb"4 5"\cr\hline
    \verb"10 20 30 123 40 50 45 890" & \verb"8 9"\cr\hline    
    
    \end{tabular}
\end{table}



\textsc{Задача 7.}  Дан текст, состоящий из предложений, разделённых знаками препинания из набора «.?!». Предложения в свою очередь состоят из слов, отделённых друг от друга пробелами. Найти слова (без учёта регистра) и их количество, которые встречаются только в повествовательных и вопросительных предложениях.\\

Листинг \verb"set7.cpp"
\VerbatimInput[fontsize=\footnotesize, numbers=left, numbersep=2pt]{set7.txt}

Пример:

\begin{table}[ht]
    \small
    \begin{tabular}{|p{15em}|p{15em}|}\hline
    Вход & Выход\cr\hline
   
    \verb"aaa bbb jjj." & \verb""\cr
    \verb"aaa ccc!" & \verb"bbb jjj hhh"\cr
    \verb"bbb ccc hhh?" & \verb""\cr\hline   
    
    \end{tabular}
\end{table}


\section{Отображения}\label{pril:map}

\textsc{Задача 10.}  Во входном файле задан набор слов и целых чисел, разделённых пробелами. Найти все слова, встречающиеся столько же раз, сколько последнее число.\\

Листинг \verb"map10.cpp"
\VerbatimInput[fontsize=\footnotesize, numbers=left, numbersep=2pt]{map10.txt}

Пример:

\begin{table}[ht]
    \small
    \begin{tabular}{|p{15em}|p{15em}|}\hline
    Вход & Выход\cr\hline
   
    \verb"12  a f d f a f a ra a a a 7 a" & \verb"a"\cr
    \verb"6 8 a e d s a e a e 4 a e" & \verb"a e"\cr
    \verb"6 8 a e d s a e a e 15 a e" & \verb"No words found"\cr\hline   
    
    \end{tabular}
\end{table}

\section{Использование контейнеров и алгоритмов STL}\label{pril:final}

\textsc{Задача 3.}  Свой стек, стек на основе массива, сравнить со стеком STL.\\

Листинг \verb"final.cpp"
\VerbatimInput[fontsize=\footnotesize, numbers=left, numbersep=2pt]{final.txt}

\end{document}
